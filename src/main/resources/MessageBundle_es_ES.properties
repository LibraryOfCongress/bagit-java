#X-Generator: crowdin.com
#default is English, United States (en_US). This is used to store all messages in bagit-java

#for BagitProfileDeserializer.java
fetch_allowed=\u00bfSe permiten archivos de recuperaci\u00f3n? [{}]
serialization_allowed=Serializaci\u00f3n es\: [{}]
parsing_bagit_profile_info_section=An\u00e1lisis de la secci\u00f3n de informaci\u00f3n de perfil BagIt
identifier=Identificador es [{}]
source_organization=Organizaci\u00f3n de la fuente es [{}]
contact_name=Nombre del contacto es [{}]
contact_email=Email del contacto es [{}]
external_description=Descripci\u00f3n externa es [{}]
version=La versi\u00f3n es [{}]
parsing_bag_info=An\u00e1lisis de la secci\u00f3n de la bag-info
required_manifest_types=Requerido tipos manifestados {}
acceptable_serialization_mime_types=Tipos de serializaci\u00f3n MIME aceptable son {}
required_tagmanifest_types=Los tipos de Tagmanifest requeridos son {}
tag_files_required=Archivos de la etiqueta requeridos son {}
acceptable_bagit_versions=Versiones aceptables de bagit son {}

#for BagitWarning.java
bag_within_a_bag=Un directorio de data puede contener cualquier cosa, incluyendo otro bag. Sin embargo, ser\u00eda mejor fusionar bags juntas.
different_case=El bag contiene dos archivos que difieren s\u00f3lo en caso. Esto puede causar problemas con los archivos del sistema como el usado por apple (HFS).
different_normalization=El bag contiene dos archivos que difieren s\u00f3lo en la normalizaci\u00f3n. Esto puede causar que la verificaci\u00f3n falle en algunos sistemas, y confusi\u00f3n del usuario general.
extra_lines_in_bagit_files=Las especificaciones bagits dicen que s\u00f3lo deben contener 2 l\u00edneas. Sin embargo, algunas implementaciones han decidido ignorar esto lo que puede causar problemas de compatibilidad
leading_dot_slash=Un manifiesto lista todos los archivos de data como relativo al directorio ra\u00edz de bolsa, es in\u00fatil por lo tanto especificarlo con un punto.
non_standard_algorithm=The checksum algorithm used does not come standard with the Java runtime. Consider using SHA-512 instead.
md5sum_tool_generated_manifest=The manifest was created using checksum utilities such as those contained in the GNU Coreutils package (md5sum, sha1sum, etc.), collectively referred to here as 'md5sum'. This creates slight differences in generated manifests that can cause problems in some implementations.
missing_tag_manifest=The tag manifest guards against a truncated payload manifest as well as other potential problems and is always recommened that it be included.
old_bagit_version=La versi\u00f3n especificaci\u00f3n bagit no es la m\u00e1s nueva. Considera convertir a la \u00faltima versi\u00f3n.
os_specific_files=Archivos creados por el sistema operativo (SO) para su propio uso. Esos son no-portables a trav\u00e9s de la versiones SO y no deber\u00edan ser incluidas en ning\u00fan manifiesto. Ejemplos son Thumb.db en Windows o .DS_Store en OS X
payload_oxum_missing=Es recomendado siempre incluir la Carga-Oxum en el metadata bag debido a que permite para una "r\u00e1pida verificaci\u00f3n" del bag.
tag_files_encoding=Es recomendado siempre usar UTF-8.
weak_checksum_algorithm=The checksum algorithm used is known to be weak. We recommend using SHA-512.

#for BagLinter.java
checking_encoding_problems=Comprobando problemas de codificaci\u00f3n.
checking_latest_version=Checking for latest version.
checking_manifest_problems=Checking manifests for problems.
checking_metadata_problems=Checking bag metadata for problems.
skipping_check_extra_lines=Skipping check for extra lines in bagit files.
checking_extra_lines=Checking if [{}] contains more than 2 lines.
extra_lines_warning=La especificaciones bagit dice que el archivo bagit.txt debe contener exactamente 2 l\u00edneas. Sin embargo, encontramos [{}] l\u00edneas, algunas implementaciones ignorar\u00e1n esto pero puede causar problemas incompatibilidad con otras herramientas.

#for BagProfileChecker.java
checking_fetch_file_allowed=Comprobar si el archivo de recuperaci\u00f3n es permitido para bag [{}].
checking_metadata_entry_required=Comprobar si [{}] es requerido en el metadata bag.
check_values_acceptable=Comprobar si todo los valores listados para [{}] son aceptables.
check_required_manifests_present=Comprobar si todos los manifiestos requeridos est\u00e1n presentes.
required_tag_manifest_type_not_present=Required tag manifest type [{}] was not present. 
required_manifest_type_not_present=Tipo de manifesto requerido [{}] no estaba presente. 
checking_required_tag_file_exists=Comprobar si todo los archivos de etiqueta requerida existen.

#for BagitVersionIsNotAcceptableException.java
bagit_version_not_acceptable_error=Versi\u00f3n [{}] no est\u00e1 en la lista aceptable de {}.

#for RequiredMetadataFieldNotPresentException.java
required_metadata_field_not_present_error=\u00a1Campo que especifica metadata [{}] es requerido pero no se encontr\u00f3\!

#for FetchFileNotAllowedException.java
fetch_file_not_allowed_error=Fetch File was found in bag [{}]\!

#for MetadataValueIsNotAcceptableException.java
metadata_value_not_acceptable_error=Profile specifies that acceptable values for [{}] are {} but found [{}]\!

#for MetadataValueIsNotRepeatableException.java
metadata_value_not_repeatable_error=Profile specifies that value [{}] is not repeatable, but was listed multiple times\!

#for RequiredTagFileNotPresentException.java
required_tag_file_not_found_error=Required tag file [{}] was not found\!

#for EncodingChecker.java
tag_files_not_encoded_with_utf8_warning=Archivos de etiqueta se codifican con [{}]. Recomendamos siempre usar UTF-8 en su lugar.

#For ManifestChecker.java
bag_missing_tag_manifest_warning=Bag [{}] no contiene un manifiesto tag, lo cual siempre es recomendado.
different_case_warning=En manifiesto [{}], ruta [{}] es igual a otra excepto para el caso. Esto puede causar problemas si mueve el bag a un archivo de sistemas que es caso sensitivo.
manifest_line_violated_spec_error=Manifiesto contiene l\u00ednea [{}] la cual no sigue la forma especificada de <CHECKSUM> <PATH>
md5sum_generated_line_warning=Ruta [{}] comienza con un *, lo cual significa que fue generado con una herramienta no bagit. Es recomendado remover el * para poder cumplir con las especificaciones bagit.
cannot_access_parent_path_error=No se pudo acceder a la carpeta principal de [{}].
different_normalization_in_manifest_warning=File [{}] has a different normalization than what is specified in the manifest.
bag_within_bag_warning=Recomendamos efusivamente no guardar un bag en un bag ya que se sabe que causa problemas.
leading_dot_slash_warning=En manifiesto [{}] l\u00ednea [{}] es una ruta no normalizada.
os_specific_files_warning=En manifiesto [{}] l\u00ednea [{}] contiene un archivo espec\u00edfico de SO.
weak_algorithm_warning=Detectado un algoritmo d\u00e9bil conocido [{}]. Con los grandes avances en hardware hay poco problema en usar m\u00e1s bits para calcular la suma de comprobaci\u00f3n.
non_standard_algorithm_warning=Algoritmo detectado [{}] el cual no es incluido por defecto en Java. Esto lo har\u00e1 m\u00e1s dif\u00edcil de leer en este bag en algunos sistemas. Considera cambiarlo a SHA-512.

#for MetadataChecker.java
missing_payload_oxum_warning=La clave Payload-Oxum no fue encontrada en la metadata bag. Esto evitar\u00e1 una "verificaci\u00f3n r\u00e1pida".

#for VersionChecker.java
old_version_warning=Versi\u00f3n encontrada [{}] de la especificaci\u00f3n bagit pero la \u00faltima versi\u00f3n es [{}].

#for AbstractCreateManifestVistor
skipping_hidden_file=Saltar [{}] ya que estamos ignorando archivos ocultos.
skipping_ignored_directory=Saltar [{}] ya que estamos ignorando directorios ocultos.

#for BagCreator.java
creating_bag=Crear un bag con versi\u00f3n\: [{}] en directorio\: [{}].
creating_payload_manifests=Crear manifiesto(s) de carga.
creating_tag_manifests=Crear etiqueta de manifiesto(s).
calculating_payload_oxum=Calcular la carga oxum del directorio de data [{}].
creating_metadata_file=Crear archivo bag de metadata (bag-info.txt o package-info.txt).

#for Hasher.java
adding_checksum=A\u00f1adir [{}] al manifesto con hash [{}].

#for UnsupportedAlgorithmException.java
algorithm_not_supported_error=\u00a1[{}] no es compatible\!

#for BagitTextFileReader.java
reading_version_and_encoding=Leer [{}] para versi\u00f3n y codificaci\u00f3n.
bagit_version=Versi\u00f3n-Bagit es [{}].
tag_file_encoding=Etiqueta de codificaci\u00f3n de caracteres de archivo es [{}].
invalid_bagit_text_file_error=\u00a1bagit.txt DEBE contener entradas\: 'Versi\u00f3n-Bagit' y 'Etiqueta de codificaci\u00f3n de caracteres de archivo'\!
bom_present_error=\u00a1Archivo [{}] contiene un marca de orden byte (BOM, por sus siglas en ingl\u00e9s) lo cual no es permitido por las especificaciones de bagit\!
strict_only_two_lines_error=El bagit.txt DEBE contener solamente 2 l\u00edneas. Extra l\u00edneas encontradas en\: [{}]
strict_first_line_error=La primera l\u00ednea del bagit.txt debe seguir el patr\u00f3n de\: [Versi\u00f3n-Bagit\: <M.N>]. Pero en su lugar encontr\u00f3 [{}]. Ver especificaciones para m\u00e1s informaci\u00f3n.
strict_second_line_error=La segunda l\u00ednea del bagit.txt debe seguir el siguiente patr\u00f3n de\: [Etiqueta de archivo de codificaci\u00f3n de caracteres\: <ENCODING>]. Pero encontr\u00f3 en su lugar\: [{}]. Ver las especificaciones para m\u00e1s informaci\u00f3n.

#for UnparsableVersionException.java
unparsable_version_error=\u00a1La versi\u00f3n debe estar en formato MAJOR.MINOR pero estaba [{}]\!

#for FetchReader.java
reading_fetch_file=Intentando leer [{}].
read_fetch_file_line=Leer URL [{}] longitud [{}] ruta [{}] del archivo recuperado [{}].
invalid_fetch_file_line_error=La l\u00ednea [{}] es inv\u00e1lida para fetch.txt. Cada l\u00ednea debe tomar la forma de <URL><LENGTH><FILENAME>.

#for KeyValueReader.java
read_key_value_line=Encontr\u00f3 clave [{}] valor [{}] en archivo [{}] usando split regex [{}].
found_indented_line=Encontr\u00f3 una l\u00ednea marcada- fusionando con su llave [{}].
malformed_key_value_line_error=L\u00ednea [{}] no cumple con las especificaciones bagit para un archivo de etiqueta bag. \u00bfTal vez quisiste marcarla con un espacio o una sangr\u00eda? \u00bfO quiz\u00e1s no usaste dos puntos para separar la clave de su valor? Debe seguir la forma de <key>{}<value> o si contin\u00faa de otra l\u00ednea debe ser marcada por un espacio o una sangr\u00eda.

#for ManifestReader.java
attempting_read_manifests=Intentando encontrar y leer manifiestos.
found_tagmanifest=Encontrado manifiesto de etiqueta [{}].
found_payload_manifest=Encontrado manifiesto de carga [{}].
reading_manifest=Leyendo manifiesto [{}].

#for MetadataReader.java
attempting_read_metadata=Intentando leer archivo de bag metadata.
found_metadata_file=Encontrado archivo metadata [{}].

#for TagFileReader.java
removing_asterisk=\u00a1Encontrada ruta que fue creada de una herramienta no-bagit. Removiendo * de ruta\!. Por favor, \u00a1quite todos los * de los archivos de manifiesto\!
blackslash_used_as_path_separator_error=[{}] is invalid due to the use of the path separator [\\]\!
malicious_path_error=\u00a1[{}] est\u00e1 tratando de ser malicioso y acceder a un archivo fuera del bag\!
invalid_url_format_error=\u00a1URL [{}] es inv\u00e1lido\!

#for BagVerifier.java
checking_bag_is_valid=Comprobando si bag con directorio root [{}] es v\u00e1lido.
checking_payload_checksums=Comprobando que suma de comprobaci\u00f3n de manifiesto de carga.
checking_tag_file_checksums=Comprobando suma de comprobaci\u00f3n de manifiesto(s) de etiqueta.
checksums_not_matching_error=Errores [{}] ocurrieron. Al menos uno de esos errores se debe a los hashes que no coinciden.
checking_bag_is_complete=Comprobando si el bag con directorio root [{}] est\u00e1 completo.

#for CheckIfFileExistsTask.java
different_normalization_on_filesystem_warning=\u00a1Nombre de archivo [{}] tiene una diferente normalizaci\u00f3n de lo que est\u00e1 contenido en archivos del sistema\!
error_reading_normalized_file=\u00a1Error mientras trataba de leer [{}] para ver si alg\u00fan archivo en ese directorio coincide con los nombre de archivo normalizados de [{}]\!

#for CheckManifestHashesTask.java
checking_checksums=Comprobando si nombre de archivo [{}] para ver si la suma de comprobaci\u00f3n coincide con [{}].

#for CorruptChecksumException.java
corrupt_checksum_error=Se supone que el archivo [{}] tiene un [{}] hash de [{}] pero fue computado como [{}].

#for FileCoundAndTotalSizeVisitor.java
file_size_in_bytes=File [{}] has a size of [{}] bytes.

#for MandatoryVerifier.java
checking_fetch_items_exist=Comprobando si todos los \u00edtems [{}] en fetch.txt existen en el directorio [{}].
fetch_item_missing_error=\u00a1Item recuperado [{}] no ha sido tra\u00eddo\!
file_should_exist_error=\u00a1Archivo [{}] deber\u00eda existir pero no es as\u00ed\!
checking_payload_directory_exists=Comprobar si el directorio de carga especial existe (s\u00f3lo para versiones 0.97 y anteriores).

#for MissingPayloadManifestException.java
missing_payload_manifest_error=\u00a1Bag no contiene un archivo de manifiesto de carga\!

#for PayloadFileExistsInAllManifestsVistor.java
file_not_in_manifest_error=\u00a1Archivo [{}] est\u00e1 en el directorio de carga pero no est\u00e1 listado en manifiesto manifiesto-{}.txt\!
file_in_all_manifests=[{}] est\u00e1 en todos los manifiestos.
file_not_in_any_manifest_error=\u00a1Archivo [{}] est\u00e1 en el directorio de carga pero no est\u00e1 listado en ning\u00fan manifiesto\!

#for PayloadVerifier.java
all_files_in_manifests=Conseguir todos los archivos listado en el/los manifiesto(s).
get_listing_in_manifest=Conseguir los archivos y sumas de comprobaci\u00f3n listados en [{}].
check_all_files_in_manifests_exist=Comprobar si todos los archivos listados en el/los manifiesto(s) existen.
missing_payload_files_error=\u00a1Manifiesto(s) contiene(n) archivo(s) {} pero no existe(n)\!
checking_file_in_at_least_one_manifest=Comprobar si todos los archivos de carga (archivos en directorio [{}]) son listado en al menos un manifiesto.
checking_file_in_all_manifests=Comprobar si todos los archivos de carga (archivos en directorio [{}]) est\u00e1n listado en todos los manifiestos.

#for QuickVerifier.java
found_payload_oxum=Found Payload-Oxum [{}] for bag [{}].
payload_oxum_missing_error=\u00a1Payload-Oxum no existe en bag\!
parse_size_in_bytes=Analizando [{}] para el tama\u00f1o de bytes total de la payload-oxum.
parse_number_of_files=Analizando [{}] para el n\u00famero de archivos a buscar en el directorio de carga.
compare_payload_oxums=Supplied payload-oxum\: [{}], Calculated payload-oxum\: [{}.{}], for payload directory [{}].
invalid_total_size_error=Tama\u00f1o total inv\u00e1lido. \u00a1Esperado [{}] pero calculado [{}]\!
invalid_file_cound_error=N\u00famero de archivo inv\u00e1lido. \u00a1Esperado [{}] pero encontrado [{}]\!

#for BagitFileWriter.java
write_bagit_file_to_path=Escribiendo archivo bagit.txt a [{}]
writing_line_to_file=Escribiendo linea [{}] a [{}]

#for BagWriter.java
writing_payload_files=Escribiendo archivos de carga.
upsert_payload_oxum=Ingresar y actualizar payload-oxum.
writing_bagit_file=Escribiendo el archivo bagit.txt.
writing_payload_manifests=Escribiendo manifiesto(s) de carga(s).
writing_bag_metadata=Escribiendo el metadata bag.
writing_fetch_file=Escribiendo el archivo de recuperaci\u00f3n.
writing_tag_manifests=Escribiendo la etiqueta(s) manifiesto(s).

#for FetchWriter.java
writing_fetch_file_to_path=Escribiendo fetch.txt a [{}].

#for ManifestWriter.java
writing_manifest_to_path=Escribiendo manifiesto a [{}].

#for MetadataWriter.java
writing_metadata_to_path=Escribiendo el archivo de metadata bag de [{}] a [{}].

#for PayloadWriter.java
writing_payload_file_to_path=Escribiendo archivo de carga de [{}] a [{}].
skip_fetch_item_when_writing_payload=Saltar archivo de carga {} porque est\u00e1 en la lista de recuperados.
